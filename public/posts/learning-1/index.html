<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">

    <meta name="author" content="John Doe">
    <meta name="description" content="很多人都在反映一个问题，看了很多书，很多视频却没学到多少东西，技术仍然很菜。这是为什么呢。 原因其实很简单，
你其实什么都没会， 但是你的大脑欺骗你。   这个时候你的大脑只是单纯的输入，在你大脑形成了短期记忆，让你认为你理解了，过一段时间浅层记忆消失，你大概率只记得几个名词， 没有任何实用价值。 举个例子说明，有一天你学习算法，你看了一本书，或者视频， 学习了递归的这个概念。  以下是另一个可能更有利于理解递归过程的解释： 递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。 我们已经完成了吗？如果完成了，返回结果。如果没有这样的终止条件，递归将会永远地继续下去。 如果没有，则简化问题，解决较容易的问题，并将结果组装成原始问题的解决办法。然后返回该解决办法。 这样就有一种更有趣的描述：“为了理解递归，则必须首先理解递归。”或者更准确地，按照安德鲁·普洛特金的解释：“如果你已经知道了什么是递归，只需记住答案。否则，找一个比你更接近侯世达的人；然后让他／她来告诉你什么是递归。”[1]
  斐波那契数列是典型的递归案例：
 if n== 1 { return 1 } return func(n-1) &#43; func(n-2) } 这个时候，你很容易感觉自己已经学会了递归的这个概念， 别人问你递归是什么， 你张嘴回答: 递归就是自己调用自己。 但其实，这个时候， 你只是记忆了文章的一些知识点，或者几句话 当你遇到一个真实的情况， 你就蒙了。例如这个题目
 第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？
 浅层知识的四个层次 你会遇到如下几种情况
 你想不起来要用递归 我知道用递归但是我学习递归的时候，使用的是斐波那契序列 fn = fn(n-1) &#43; fn(n-2)， 这个感觉和斐波那契差别太大。 你知道要用递归，但是你不知道这个题目要怎么对应递归。 你写了一部分递归，但是代码出现了问题， 跑不出正确的答案。  在做这倒题目的时候， 学过了知道第一直觉是用递归， 第十天，桃子只剩下一个桃子，是明显是递归的终止条件。 (递归一定要有终止条件， 否则是无线递归，直到溢出)
那我就写出来了。
func stolenPeach(n) { if n == 10 { return 1 } } 然后知道递归需要调用自己。则可以这么写">
    <meta name="keywords" content="blog,developer,personal">

    
      <script src="https://twemoji.maxcdn.com/v/latest/twemoji.min.js" crossorigin="anonymous"></script>
    

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="为什么只看视频/书却学不会东西。"/>
<meta name="twitter:description" content="很多人都在反映一个问题，看了很多书，很多视频却没学到多少东西，技术仍然很菜。这是为什么呢。 原因其实很简单，
你其实什么都没会， 但是你的大脑欺骗你。   这个时候你的大脑只是单纯的输入，在你大脑形成了短期记忆，让你认为你理解了，过一段时间浅层记忆消失，你大概率只记得几个名词， 没有任何实用价值。 举个例子说明，有一天你学习算法，你看了一本书，或者视频， 学习了递归的这个概念。  以下是另一个可能更有利于理解递归过程的解释： 递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。 我们已经完成了吗？如果完成了，返回结果。如果没有这样的终止条件，递归将会永远地继续下去。 如果没有，则简化问题，解决较容易的问题，并将结果组装成原始问题的解决办法。然后返回该解决办法。 这样就有一种更有趣的描述：“为了理解递归，则必须首先理解递归。”或者更准确地，按照安德鲁·普洛特金的解释：“如果你已经知道了什么是递归，只需记住答案。否则，找一个比你更接近侯世达的人；然后让他／她来告诉你什么是递归。”[1]
  斐波那契数列是典型的递归案例：
 if n== 1 { return 1 } return func(n-1) &#43; func(n-2) } 这个时候，你很容易感觉自己已经学会了递归的这个概念， 别人问你递归是什么， 你张嘴回答: 递归就是自己调用自己。 但其实，这个时候， 你只是记忆了文章的一些知识点，或者几句话 当你遇到一个真实的情况， 你就蒙了。例如这个题目
 第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？
 浅层知识的四个层次 你会遇到如下几种情况
 你想不起来要用递归 我知道用递归但是我学习递归的时候，使用的是斐波那契序列 fn = fn(n-1) &#43; fn(n-2)， 这个感觉和斐波那契差别太大。 你知道要用递归，但是你不知道这个题目要怎么对应递归。 你写了一部分递归，但是代码出现了问题， 跑不出正确的答案。  在做这倒题目的时候， 学过了知道第一直觉是用递归， 第十天，桃子只剩下一个桃子，是明显是递归的终止条件。 (递归一定要有终止条件， 否则是无线递归，直到溢出)
那我就写出来了。
func stolenPeach(n) { if n == 10 { return 1 } } 然后知道递归需要调用自己。则可以这么写"/>

    <meta property="og:title" content="为什么只看视频/书却学不会东西。" />
<meta property="og:description" content="很多人都在反映一个问题，看了很多书，很多视频却没学到多少东西，技术仍然很菜。这是为什么呢。 原因其实很简单，
你其实什么都没会， 但是你的大脑欺骗你。   这个时候你的大脑只是单纯的输入，在你大脑形成了短期记忆，让你认为你理解了，过一段时间浅层记忆消失，你大概率只记得几个名词， 没有任何实用价值。 举个例子说明，有一天你学习算法，你看了一本书，或者视频， 学习了递归的这个概念。  以下是另一个可能更有利于理解递归过程的解释： 递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。 我们已经完成了吗？如果完成了，返回结果。如果没有这样的终止条件，递归将会永远地继续下去。 如果没有，则简化问题，解决较容易的问题，并将结果组装成原始问题的解决办法。然后返回该解决办法。 这样就有一种更有趣的描述：“为了理解递归，则必须首先理解递归。”或者更准确地，按照安德鲁·普洛特金的解释：“如果你已经知道了什么是递归，只需记住答案。否则，找一个比你更接近侯世达的人；然后让他／她来告诉你什么是递归。”[1]
  斐波那契数列是典型的递归案例：
 if n== 1 { return 1 } return func(n-1) &#43; func(n-2) } 这个时候，你很容易感觉自己已经学会了递归的这个概念， 别人问你递归是什么， 你张嘴回答: 递归就是自己调用自己。 但其实，这个时候， 你只是记忆了文章的一些知识点，或者几句话 当你遇到一个真实的情况， 你就蒙了。例如这个题目
 第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？
 浅层知识的四个层次 你会遇到如下几种情况
 你想不起来要用递归 我知道用递归但是我学习递归的时候，使用的是斐波那契序列 fn = fn(n-1) &#43; fn(n-2)， 这个感觉和斐波那契差别太大。 你知道要用递归，但是你不知道这个题目要怎么对应递归。 你写了一部分递归，但是代码出现了问题， 跑不出正确的答案。  在做这倒题目的时候， 学过了知道第一直觉是用递归， 第十天，桃子只剩下一个桃子，是明显是递归的终止条件。 (递归一定要有终止条件， 否则是无线递归，直到溢出)
那我就写出来了。
func stolenPeach(n) { if n == 10 { return 1 } } 然后知道递归需要调用自己。则可以这么写" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://maxjohnxiang.github.io/posts/learning-1/" />
<meta property="article:published_time" content="2019-11-07T13:42:11+08:00" />
<meta property="article:modified_time" content="2019-11-07T13:42:11+08:00" />


    
      <base href="https://maxjohnxiang.github.io/posts/learning-1/">
    
    <title>
  为什么只看视频/书却学不会东西。 · Max的blog
</title>

    
      <link rel="canonical" href="https://maxjohnxiang.github.io/posts/learning-1/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.13.0/css/all.css" integrity="sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://maxjohnxiang.github.io/css/coder.min.3219ef62ae52679b7a9c19043171c3cd9f523628c2a65f3ef247ee18836bc90b.css" integrity="sha256-MhnvYq5SZ5t6nBkEMXHDzZ9SNijCpl8&#43;8kfuGINryQs=" crossorigin="anonymous" media="screen" />
    

    

    

    

    

    <link rel="icon" type="image/png" href="https://maxjohnxiang.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://maxjohnxiang.github.io/images/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.80.0" />
  </head>

  
  
  <body class="colorscheme-light"
        onload=" twemoji.parse(document.body); "
  >
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://maxjohnxiang.github.io/">
      Max的blog
    </a>
    
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://maxjohnxiang.github.io/posts/">Blog</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://maxjohnxiang.github.io/projects/">Projects</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://maxjohnxiang.github.io/contact/">Contact me</a>
          </li>
        
      
      
    </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">为什么只看视频/书却学不会东西。</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2019-11-07T13:42:11&#43;08:00'>
                November 7, 2019
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              2-minute read
            </span>
          </div>
          
          
        </div>
      </header>

      <div>
        
        <p>很多人都在反映一个问题，看了很多书，很多视频却没学到多少东西，技术仍然很菜。这是为什么呢。
原因其实很简单，</p>
<h2 id="你其实什么都没会-但是你的大脑欺骗你">你其实什么都没会， 但是你的大脑欺骗你。</h2>
<blockquote>
</blockquote>
<h2 id="举个例子说明有一天你学习算法你看了一本书或者视频-学习了递归的这个概念">这个时候你的大脑只是单纯的输入，在你大脑形成了短期记忆，让你认为你理解了，过一段时间浅层记忆消失，你大概率只记得几个名词， 没有任何实用价值。
举个例子说明，有一天你学习算法，你看了一本书，或者视频， 学习了递归的这个概念。</h2>
<blockquote>
<p>以下是另一个可能更有利于理解递归过程的解释：
递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。
我们已经完成了吗？如果完成了，返回结果。如果没有这样的终止条件，递归将会永远地继续下去。
如果没有，则简化问题，解决较容易的问题，并将结果组装成原始问题的解决办法。然后返回该解决办法。
这样就有一种更有趣的描述：“为了理解递归，则必须首先理解递归。”或者更准确地，按照安德鲁·普洛特金的解释：“如果你已经知道了什么是递归，只需记住答案。否则，找一个比你更接近侯世达的人；然后让他／她来告诉你什么是递归。”[1]</p>
</blockquote>
<blockquote>
<p>斐波那契数列是典型的递归案例：</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">if n== 1 {
    return 1
}
return func(n-1) + func(n-2)
}
</code></pre></div><p>这个时候，你很容易感觉自己已经学会了递归的这个概念， 别人问你递归是什么， 你张嘴回答:
递归就是自己调用自己。
但其实，这个时候， 你只是记忆了文章的一些知识点，或者几句话  当你遇到一个真实的情况， 你就蒙了。例如这个题目</p>
<blockquote>
<p>第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？</p>
</blockquote>
<h4 id="浅层知识的四个层次">浅层知识的四个层次</h4>
<p>你会遇到如下几种情况</p>
<ol>
<li>你想不起来要用递归</li>
<li>我知道用递归但是我学习递归的时候，使用的是斐波那契序列 fn = fn(n-1) + fn(n-2)， 这个感觉和斐波那契差别太大。</li>
<li>你知道要用递归，但是你不知道这个题目要怎么对应递归。</li>
<li>你写了一部分递归，但是代码出现了问题， 跑不出正确的答案。</li>
</ol>
<p>在做这倒题目的时候， 学过了知道第一直觉是用递归， 第十天，桃子只剩下一个桃子，是明显是递归的终止条件。 (递归一定要有终止条件， 否则是无线递归，直到溢出)</p>
<p>那我就写出来了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">stolenPeach</span>(n) {
    <span style="color:#ff79c6">if</span> n <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">10</span> {
        <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">1</span>
    }
}
</code></pre></div><p>然后知道递归需要调用自己。则可以这么写</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">stolenPeach</span>(n) {
    <span style="color:#ff79c6">if</span> n <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">10</span> {
        <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">1</span>
    }
    <span style="color:#ff79c6">return</span> 调用自己()   此时还不知道。 只是把框架写出来了。 
}
</code></pre></div><p>这个时候，你如果学过递归， 你应该可以写到这里， 但是这个时候还差多少呢。
应该还差60%吧，也就是说还差得远。
因为递归最重要的是， 这个时候最重要的是， 猴子偷桃的数量之间有什么关系， 然后把这个关系总结成公式
#第十只猴子来的时候，只有一个桃子
标记总桃子数量为n
那么求第一个猴子，偷的了多少桃子。
求总桃子的数量， 那么等于第一个猴子剩下的桃子 n1  * 2 +1
那么需要求第二个猴子偷的桃子的数量 ，等于第三个猴子偷桃的数量 *2 +1  n3 =n2 *2 +1  就是第二个个猴子的偷的数量</p>
<p>第1只猴子拿了总数的一半加一   n1 = n/2 +1  //剩下n1个桃子
第2只猴子拿了剩下的桃子一半+1 n2 = n1/2 +1   //第二个猴子拿走了n1个桃子了一半+1
第3只猴子拿了剩下的桃子一半+1 n3 = n1/2 +1
第4只猴子拿了剩下的桃子一半+1 n4 = n1/2 +1
第5只猴子拿了剩下的桃子一半+1 n5 = n1/2 +1
第6只猴子拿了剩下的桃子一半+1 n6 = n1/2 +1
第7只猴子拿了剩下的桃子一半+1 n7 = n1/2 +1
第8只猴子拿了剩下的桃子一半+1 n8 = n1/2 +1
第9只猴子拿了剩下的桃子一半+1 n9 = n1/2 +1
第10只猴子拿了剩下的桃子一半+1 n10 = n1/2 +1
n10=1</p>
<p>这个时候通过总结归纳， 把猴子偷桃的数量写下来。 开始分析，
得出了这个结论。 n = 2 * (n+1) +1
这个时候， 我们再完成最终的代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">stolenPeach</span>(n) {
    <span style="color:#ff79c6">if</span> n <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">10</span> {
        <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">1</span>
    }
    <span style="color:#ff79c6">return</span> <span style="color:#bd93f9">2</span> <span style="color:#ff79c6">*</span> <span style="color:#50fa7b">stolenPeach</span>(n<span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>) <span style="color:#ff79c6">+</span><span style="color:#bd93f9">1</span>    
}
</code></pre></div><p>一开始的桃子数量为: stolenPeach(1)</p>
<p>这个时候我做出来了这个题目， 我想用这个例子说明什么呢。 你只是单纯的记忆了知识的话， 那这个记忆不属于你。  这个知识并没有经过你的大脑归纳处理和其他的知识产生链接。
<strong>并且在这个过程中， 你的大脑会欺骗你， 自己已经完全掌握了。</strong>
你记得一句话，递归就是自己调用自己。<br>
这个时候你掌握的知识知识最浅层的知识，基本无法使用。
举个例子， 你有一个500平的大别墅， 别墅里面有特别多东西，有一天别人告诉你一个东西洗碗机很有用，可以用来洗大量碗。 你听了有道理， 把它放在角落里面， 感到了心满意足。</p>
<ol>
<li>突然有一天你有五百个碗要洗， 你甚至不知道你可以用洗碗机解决问题</li>
<li>因为你当时仔细了解了洗碗机的使用范围， 你知道可以用洗碗机，但是你找不到这个机器在哪里， 因为家里机器太多了。</li>
<li>你找到了洗碗机， 但是你不知道如何使用，</li>
<li>你使用了洗碗机， 因为没有特别深刻了解，点错了按钮，没有放洗碗粉等，碗洗的不干净。</li>
</ol>
<p>这个例子就是单纯看视频或者阅读学习的过程。从1-4 ，没一层次都是一个理解的层次。</p>
<ol>
<li>你看了这本书，你不知道这个知识点可以用于干什么。</li>
<li>你知道知识点可以用来的干什么， 但是你不知道怎么用。</li>
<li>你会用， 但是因为了解的不清楚，所以用错了。</li>
<li>你非常了解这个知识的使用场景， 并且用于各种场景。</li>
</ol>
<h2 id="如何将浅层理解跃迁到深层理解">如何将浅层理解跃迁到深层理解</h2>
<p>任何的知识的掌握一般都是从这几个步骤开始， 从浅层知识逐步到深层知识的理解，
那么如何从浅层知识慢慢过渡到深度了解呢。
其实就两点有效输入和有有效输出， 为什么被动的看书学不会， 就是因为这个知识没有经过任何处理。  想象一下， 你写了一个爬虫， 从各大网站抓取了信息， 然后全放在本地文件中了，没有任何分门别类，这些知识是否可以为你所用呢，一共500G  当然不能，当你用的时候， 你只能把硬盘遍历一遍才能找到你需要的数据。 是因为这写数据，没有进行任何处理，所以没有实用价值。 为了让数据能为我们所用，当我们爬取的数据的时候，首先要清洗数据， 将不要的数据， 错误的数据筛出去，然后结构化数据，例如按照来源，网站来源，主题存在mysql数据库不同数据表中，分门别类的存在各个地方，这个时候你用的时候，一个sql语句就能找到你需要的数据。 这个例子想说明， 单纯的读书看视频， 和从网上download一堆数据到你硬盘一样， 没经过清洗，归纳的数据，是没有任何价值的。
所以当学习一门知识， 最主要的输出建立，输入和输出任务，让这些数据完全成为你知识体系的一部分。</p>
<h4 id="通常有如下几个手段">通常有如下几个手段</h4>
<ol>
<li>记录笔记，阅读相关文章，书籍， 思维导图整理，anki，为了防止遗忘反复的输入。</li>
<li>输出最好的则是， 记录博客，写题目， 做项目实战。</li>
</ol>
<h2 id="知识转化流水线">知识转化流水线</h2>
<p>所以一个知识的掌握过程， 应该是一个流水线(pipeline)如下图
以所一个知识的掌握流程,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">st=&gt;start: Start|past:&gt;http://www.google.com[blank]
e=&gt;end: End:&gt;http://www.google.com
op1=&gt;operation: My Operation|past
op2=&gt;operation: Stuff|current
sub1=&gt;subroutine: My Subroutine|invalid
cond=&gt;condition: Yes
or No?|approved:&gt;http://www.google.com
c2=&gt;condition: Good idea|rejected
io=&gt;inputoutput: catch something...|request

st-&gt;op1(right)-&gt;cond
cond(yes, right)-&gt;c2
cond(no)-&gt;sub1(left)-&gt;op1
c2(yes)-&gt;io-&gt;e
c2(no)-&gt;op2-&gt;e
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">st=&gt;start: 阅读吸收
e=&gt;end: 结束:&gt;http://www.google.com
op1=&gt;operation: 进行主题阅读|past
op2=&gt;operation: 做题自测|current
op3=&gt;operation: 写博客|current
cond2=&gt;condition: Anki复习|current
cond1=&gt;condition: 是否可写出相关题目

st-&gt;op1-&gt;op2-&gt;cond1
cond1(yes)-&gt;op3
cond1(no)-&gt;op1
op3-&gt;cond2
cond2(no)-&gt;op2
cond2(yes)-&gt;e
</code></pre></div>
      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>Enter a text here.</p>
      
      
        ©
        
          2019 -
        
        2022
         John Doe 
      
      
         · 
        Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
      
      
        
      
    </section>
  </footer>

    </main>

    

    

    <script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '//analytics.example.com/tracker.js', 'fathom');
fathom('set', 'siteId', 'ABCDE');
fathom('trackPageview');
</script>


  </body>

</html>
