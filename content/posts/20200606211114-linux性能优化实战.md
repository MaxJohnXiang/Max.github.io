+++
title = "Linux性能优化实战"
author = ["项云"]
date = 2020-06-19
lastmod = 2020-07-13T11:20:16+08:00
draft = false
+++

<div class="ox-hugo-toc toc">
<div></div>

<div class="heading">Table of Contents</div>

- [内存](#内存)
    - [地址空间](#地址空间)
    - [内存分配](#内存分配)
    - [缓存命中率](#缓存命中率)
    - [内存泄露](#内存泄露)
- [CPU 上下文   而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。](#cpu-上下文-而是因为系统在很短的时间内-将-cpu-轮流分配给它们-造成多任务同时运行的错觉)
- [Neword 网络](#neword-网络)
    - [CIDR](#cidr)
    - [网络协议](#网络协议)
    - [网络请求](#网络请求)
    - [网络包的接收流程](#网络包的接收流程)
    - [网络指标](#网络指标)
- [Docker](#docker)
    - [优点](#优点)
    - [概念](#概念)
    - [基础技术](#基础技术)
    - [常用命令](#常用命令)
    - [案例](#案例)

</div>
<!--endtoc-->



## 内存 {#内存}


### 地址空间 {#地址空间}


#### 内存映射 {#内存映射}


#### 地址空间(存储的抽象) {#地址空间--存储的抽象}

<!--list-separator-->

-  抽象的原因

    -   用户可以寻址每个字节, 可以轻易的破坏操作系统
    -   多个进程运行的时候, 地址冲突

<!--list-separator-->

-  地址空间的概念

    -   地址空间是一个可用于寻址的的一套地址集合
        1.  电话号码的空间是0000 0000 9999999
        2.  ipv4的地址空间是32bit 数字, 所以地址空间为 2^32-1
        3.  com 是2-64个字符后面接着.com 域名的字符组成的空间

<!--list-separator-->

-  虚拟内存

    -   有了虚拟内存机制之后，每次访问可以使用更易理解的虚拟地址，让CPU转换成实际的物理地址访问内存，降低了直接使用、管理物理内存的门槛
    -   物理内存按大小被分成页框、页，每块物理内存可以被映射为一个或多个虚拟内存页。这块映射关系，由操作系统的页表来保存，页表是有层级的
    -   高层级的页表包含指向低层级页表的物理地址，指向顶级的页表的地址，驻留在寄存器中
    -   page cache 最常见的操作，每次读取文件时，数据都会被放入页面缓存中，以避免后续读取时所进行昂贵的磁盘访问。

    <!--list-separator-->

    -  内核空间

        -   用户只有进入内核空间的时候,才能方位内核空间的内存

    <!--list-separator-->

    -  用户空间

    <!--list-separator-->

    -  内存映射

        -   Page table 内核为每个进程维护了一张页表, 记录虚拟地址和物理地址的映射关系.,


#### 内存回收 {#内存回收}

<!--list-separator-->

-  OOM killer

    -   内存耗尽后, 杀掉一些进程回收资源

<!--list-separator-->

-  对文件页的回收，当然就是直接回收缓存，或者把脏页写回磁盘后再回收。

<!--list-separator-->

-  而对匿名页的回收，其实就是通过 Swap 机制，把它们写入磁盘后再释放内存。 (swap)

<!--list-separator-->

-  wappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页


#### Swap {#swap}

<!--list-separator-->

-  把一块磁盘空间或者一个本地文件（以下讲解以磁盘为例），当成内存来使用

    -   换出，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存。
    -   换入，则是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来

<!--list-separator-->

-  NUMA


#### 提高内存性能 {#提高内存性能}

-   禁止 Swap
-   试降低 swappiness 的值
-   响应延迟敏感的应用，如果它们可能在开启 Swap 的服务器中运行，你还可以用库函数 mlock() 或者 mlockall() 锁定内存，阻止它们的内存换出。


### 内存分配 {#内存分配}


#### 分页 {#分页}

-   Linux内核管理物理内存是通过分页机制实现的，它将整个内存划分成无数个4k（在i386体系结构中）大小的页，从而分配和回收内存的基本单位便是内存页了。


#### slab {#slab}

-   需要，Linux系统采用了一种被称为slab分配器的技术。Slab分配器的实现相当复杂，但原理不难，其核心思想就是“存储池[4]”的运用。内存片段（小块内存）被看作对象，当被使用完后，并不直接释放而是被缓存到“存储池”里，留做下次使用，这无疑避免了频繁创建与销毁对象所带来的额外负载。


#### page cache {#page-cache}

-   free -m 里面的 cache = page cache
-   Linux中通过page cache机制来加速对磁盘文件的许多访问，当它首次\*\*读取\*\*或\*\*写入\*\*数据介质时，Linux会将数据存储在未使用的内存区中，通过这些区域充当缓存，当发生写操作时，Linux不会立刻执行磁盘写操作，而是把page cache中的页面标记为脏页，定期同步到存储设备。


#### buffer {#buffer}

-   是为了提高内存和硬盘（或其他I/0设备）之间的数据交换的速度而设计的。


#### 进程与内存 {#进程与内存}

<!--list-separator-->

-  进程对应的内存空间中所包含的5种不同的数据区。

    -   代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。
    -   数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配[1]的变量和全局变量。
    -   BSS段[2]：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。
    -   堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）
    -   栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

<!--list-separator-->

-  进程内存的分配与回收

    -   创建进程fork()、
    -   程序载入execve()
    -   映射文件mmap()
    -   动态内存分配malloc()/brk()等进程


### 缓存命中率 {#缓存命中率}


#### cachestat 提供了整个操作系统缓存的读写命中情况 {#cachestat-提供了整个操作系统缓存的读写命中情况}

-   TOTAL ，表示总的 I/O 次数
-   MISSES ，表示缓存未命中的次数
-   HITS ，表示缓存命中的次数
-   DIRTIES， 表示新增到缓存中的脏页数
-   BUFFERS\_MB 表示 Buffers 的大小，以 MB 为单位
-   CACHED\_MB 表示 Cache 的大小，以 MB 为单位。


#### cachetop 提供了每个进程的缓存命中情况。 {#cachetop-提供了每个进程的缓存命中情况}


#### pcstat 那就是指定文件在内存中的缓存大小 {#pcstat-那就是指定文件在内存中的缓存大小}


### 内存泄露 {#内存泄露}


#### 常见原因 {#常见原因}

-   没正确回收分配后的内存，导致了泄漏。
-   访问的是已分配内存边界外的地址，导致程序异常退出，等等


#### memleak 可以跟踪系统或指定进程的内存分配、释放请求，然后定期输出一个未释放内存和相应调用栈的汇总情 {#memleak-可以跟踪系统或指定进程的内存分配-释放请求-然后定期输出一个未释放内存和相应调用栈的汇总情}


## CPU 上下文   而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。 {#cpu-上下文-而是因为系统在很短的时间内-将-cpu-轮流分配给它们-造成多任务同时运行的错觉}

根据任务的不同，CPU的上下文切换可以分为不同的场景，也就是进程上下文切换、线程上下文切换、中断上下文切换。


## Neword 网络 {#neword-网络}


### CIDR {#cidr}

-   将32位的地址一分为2, 前面是网络号后面是主机号
-   =10.100.122.2/24=，这个 IP 地址中有一个斜杠，斜杠后面有个数字 24。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。
-   将连续网络分配给一个组织, 外部路由表只记录一个公网的地址.


#### 广播地址 {#广播地址}

伴随着 CIDR 存在的，一个是广播地址，10.100.122.255。如果发送这个地址，所有 10.100.122 网络里面的机器都可以收到。另一个是子网掩码，255.255.255.0


#### 子网掩码 {#子网掩码}

确定网络位置的一个, 前面都是1的代表是网络位置, 后面0的代表主机位置.  通过 and 运算来得出


#### Private network {#private-network}

当你有了路由器的时候, 就有了私有地址
私有网络只能自己用 ,不能出现在公网
私有地址（Private address）属于非注册地址，专门为组织机构内部使用。
以下列出留用的内部私有地址

> A类 10.0.0.0--10.255.255.255
> B类 172.16.0.0--172.31.255.255
> C类 192.168.0.0--192.168.255.255


### 网络协议 {#网络协议}


#### DNS {#dns}

Domain Name System, 提供 ip 和域名之间的查询关系, 并提供全局负载均衡的能力.可以提供选择最近的 ip 提供能力

<!--list-separator-->

-  域名和 dns 解析

    分级别递归查询 DNS 服务器

<!--list-separator-->

-  记录资源的方式

    <!--list-separator-->

    -  A 记录

        -   域名转换 ip 地址

    <!--list-separator-->

    -  CANME  记录

        -   创建别名

    <!--list-separator-->

    -  NS

        -   域名对应的服务器的地址

<!--list-separator-->

-  相关命令

    <!--list-separator-->

    -  nslookup time.geekbang.org

    <!--list-separator-->

    -  dig +trace +nodnssec domain

    <!--list-separator-->

    -  /etc/init.d/dnsmasq start  开启 dns 缓存服务器

<!--list-separator-->

-  相关文件

    -   /etc/hosts : 在这个文件增加记录,会进行本地的 dns 解析
    -   /etc/resolv.conf : 更改 dns 服务器

<!--list-separator-->

-  案例

    <!--list-separator-->

    -  nslookup 失败

        -   检查/etc/resolv.conf

    <!--list-separator-->

    -  dns 请求特别慢

        -   time nslookup time.geekbang.org
        -   可能情况
            -   DNS 服务器有问题, 尝试更换服务器
            -   客户端到 dns 服务器的网络问题
            -   dns 的请求或者响应包丢包  通过 ping 测试


### 网络请求 {#网络请求}


#### 网络请求流程 {#网络请求流程}

-   这个地址是和我一个网段, 或者和网卡是一个网段吗
    -   是,  发送 arp 请求, 获得 mac 地址
    -   发送到网关
        -   根据 IP 找 mac 地址,


### 网络包的接收流程 {#网络包的接收流程}

-   网络帧-> DMA方式-> 网卡->收包队列->硬终端->通知程序收到-> 分配内核数据接口 sk\_buff-> copy 到 sk-buff
-   内核协议从缓冲区取出网络帧,通过\*\*网络协议栈\*\*来处理.
    -   链路层检查报文
    -   找出上层协议类型, 去掉头尾, 交给网络层
    -   取出 ip 头, 判断转发还是发送 交给传输层
-   传输层取出 tcp 头, 找出对应的 socket , 并把数据拷贝到Socket 缓存中

    {{< figure src="/ox-hugo/2020-06-21_19-48-08_3af644b6d463869ece19786a4634f765.png" >}}


### 网络指标 {#网络指标}

-   带宽，表示链路的最大传输速率，单位通常为 b/s （比特 / 秒）。
-   吞吐量，表示单位时间内成功传输的数据量，单位通常为 b/s（比特 / 秒）或者 B/s（字节 / 秒）。
-   吞吐量受带宽限制，而吞吐量 / 带宽，也就是该网络的使用率。
-   延时，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同含义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）。PPS，是 Packet Per Second（包 / 秒）的缩写，表示以网络包为单位的传输速率。PPS 通常用来评估网络的转发能力，比如硬件交换机，通常可以达到线性转发（即 PPS 可以达到或者接近理论最大值）。而基于 Linux 服务器的转发，则容易受网络包大小的影响。


#### 命令 {#命令}

<!--list-separator-->

-  ifconfig

    ```nil
    eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500 // max transfer unit
           inet 173.242.119.190  netmask 255.255.252.0  broadcast 173.242.119.255 //广播地址
           inet6 fe80::a8aa:ff:fe15:714  prefixlen 64  scopeid 0x20<link>
           ether aa:aa:00:15:07:14  txqueuelen 1000  (Ethernet)
           RX packets 167672856  bytes 192486005892 (192.4 GB)
           RX errors 0  dropped 0  overruns 0  frame 0
           TX packets 111039501  bytes 184615314607 (184.6 GB)
           TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
    ```

<!--list-separator-->

-  netstat -ntlp

    -   l 显示套接字 ,-n 显示地址和端口
    -   其中，接收队列（Recv-Q）和发送队列（Send-Q）需要你特别关注，它们通常应该是 0。当你发现它们不是 0 时，说明有网络包的堆积发生。
    -

<!--list-separator-->

-  sar -n DEV 1

    ```nil
    Average:        IFACE   rxpck/s(接收PPS)   txpck/s(发送 PPS)    rxkB/s(接收和压缩数据包数量)    txkB/s(接收和压缩数据包数量)   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
    Average:    veth9bcae06      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
    Average:         eth1      7.82      0.01      2.61      0.00      0.00      0.00      0.00      0.00
    Average:         eth0     32.32     27.45     49.97     50.12      0.00      0.00      0.00      0.00
    Average:      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00
    Average:           lo     33.97     33.97     51.11     51.11      0.00      0.00      0.00      0.00
    ```

<!--list-separator-->

-  ping

    -   icmp\_seq 序列号
    -   TTL 生存时间


#### 如何评估网络性能 {#如何评估网络性能}


#### iperf测试TCP/UDP 性能 {#iperf测试tcp-udp-性能}

-   iperf3 -c 192.168.0.30 -b 1G -t 15 -P 2 -p 10000
-   Bandwidth


#### ab 测试 http 性能 {#ab-测试-http-性能}

-   ab -c 1000 -n 10000 <http://127.0.0.1/>
    -   Requests per second rps
    -   Time per request tpr
    -   Transfer rate
    -


#### 总结 {#总结}

> 在应用层，你可以使用 wrk、Jmeter 等模拟用户的负载，测试应用程序的每秒请求数、处理延迟、错误数等
> 而在传输层，则可以使用 iperf 等工具，测试 TCP 的吞吐情况
> 再向下，你还可以用 Linux 内核自带的 pktgen ，测试服务器的 PPS。


## Docker {#docker}


### 优点 {#优点}

-   更快的启动速度：因为 Docker 直接运行于宿主内核，无需启动完整的操作系统，因此启动速度属于秒级别，而虚拟机通常需要几分钟去启动。
-   更高效的资源利用率：由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。
-   更高的系统支持量：Docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。
-   持续交付与部署：对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至进行自动部署。
-   更轻松的迁移：由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。
-   更轻松的维护与扩展：Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。
-   更弱的隔离性：Docker 属于进程之间的隔离，虚拟机可实现系统级别隔离。
-   更弱的安全性：Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为 root 权限，它就直接具备了宿主机的 root 权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且利用硬件隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击。


### 概念 {#概念}


#### 镜像 {#镜像}

Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。


#### 容器 {#容器}

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间容器可以被。创建、启动、停止、删除和暂停等等，说到镜像与容器之间的关系，可以类比面向对象程序设计中的类和实例。


#### 仓库 {#仓库}

镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry 中可以包含多个仓库；每个仓库可以包含多个标签；每个标签对应一个镜像，其中标签可以理解为镜像的版本号


### 基础技术 {#基础技术}


#### Namespaces {#namespaces}

命名空间 (namespaces) 是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方


#### 进程隔离 {#进程隔离}

<!--list-separator-->

-  两个特殊进程 created by idle

    {{< figure src="/ox-hugo/2020-06-28_23-11-31_2017-11-30-linux-processes.png" >}}

    -   `/sbin/init`
    -   `kthreadd`
    -   `clone` 函数, 克隆一个进程
        -   CLONE\_NEWPID ,  从内部重新编号 PID
        -   CLONE\_NEWNS : 通过重新挂载 proc 文件夹, 屏蔽父进程信息


#### 文件隔离 {#文件隔离}

<!--list-separator-->


    -   =cat /proc/mounts | grep system\_u:object_r:container\_file\_t:s0:c740,c923


#### 资源限制 {#资源限制}

<!--list-separator-->


    cgroups 会影响容器应用的运行；


### 常用命令 {#常用命令}


#### docker logs - f {#docker-logs-f}


#### docker inspect {#docker-inspect}

```nil
# 显示容器状态，jq用来格式化json输出
$ docker inspect tomcat -f '{{json .State}}' | jq
{
  "Status": "exited",
  "Running": false,
  "Paused": false,
  "Restarting": false,
  "OOMKilled": true,
  "Dead": false,
  "Pid": 0,
  "ExitCode": 137,
  "Error": "",
  ...
}
```


#### docker exec {#docker-exec}


#### `PID=$(docker inspect tomcat -f '{{.State.Pid}}') pidstat -t -p $PID 1` {#pid--docker-inspect-tomcat-f-dot-state-dot-pid--pidstat-t-p-pid-1}


### 案例 {#案例}


#### 容器退出案例 {#容器退出案例}

-   docker ps -a 查看状态
-   dcoker insepect 查看退出原因
-   dmesg 查看系统OOM日志
-   因为外部资源的限制, 程序内部可能无法看见


#### 启动慢分析 {#启动慢分析}

<!--list-separator-->

-  观察 top 输出, cpu , 内存等

<!--list-separator-->

-  pidstat

    发现 cpu 非常低, 但是wait 非常高, 是由于--cpus 0.1导致的
