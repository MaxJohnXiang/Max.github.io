---
title: "内存管理"
date: 2020-06-07T22:53:25+08:00
draft: false
---

# Table of Contents

1.  [内存](#org758872e)
    1.  [地址空间](#org220f21e)
    2.  [内存分配](#org7e715a5)
    3.  [缓存命中率](#org28957e8)
    4.  [内存泄露](#org1b11567)



<a id="org758872e"></a>

# 内存


<a id="org220f21e"></a>

## 地址空间


### 内存映射


### 地址空间(存储的抽象)

1.  抽象的原因

    -   用户可以寻址每个字节, 可以轻易的破坏操作系统
    -   多个进程运行的时候, 地址冲突

2.  地址空间的概念

    -   地址空间是一个可用于寻址的的一套地址集合
        1.  电话号码的空间是0000 0000 9999999
        2.  ipv4的地址空间是32bit 数字, 所以地址空间为 2<sup>32</sup>-1
        3.  com 是2-64个字符后面接着.com 域名的字符组成的空间

3.  虚拟内存

    -   有了虚拟内存机制之后，每次访问可以使用更易理解的虚拟地址，让CPU转换成实际的物理地址访问内存，降低了直接使用、管理物理内存的门槛
    -   物理内存按大小被分成页框、页，每块物理内存可以被映射为一个或多个虚拟内存页。这块映射关系，由操作系统的页表来保存，页表是有层级的
    -   高层级的页表包含指向低层级页表的物理地址，指向顶级的页表的地址，驻留在寄存器中
    -   page cache 最常见的操作，每次读取文件时，数据都会被放入页面缓存中，以避免后续读取时所进行昂贵的磁盘访问。

    1.  内核空间

        -   用户只有进入内核空间的时候,才能方位内核空间的内存

    2.  用户空间

    3.  内存映射

        -   Page table 内核为每个进程维护了一张页表, 记录虚拟地址和物理地址的映射关系.,


### 内存回收

1.  OOM killer

    -   内存耗尽后, 杀掉一些进程回收资源

2.  对文件页的回收，当然就是直接回收缓存，或者把脏页写回磁盘后再回收。

3.  而对匿名页的回收，其实就是通过 Swap 机制，把它们写入磁盘后再释放内存。 (swap)

4.  wappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页


### Swap

1.  把一块磁盘空间或者一个本地文件（以下讲解以磁盘为例），当成内存来使用

    -   换出，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存。
    -   换入，则是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来

2.  NUMA


### 提高内存性能

-   禁止 Swap
-   试降低 swappiness 的值
-   响应延迟敏感的应用，如果它们可能在开启 Swap 的服务器中运行，你还可以用库函数 mlock() 或者 mlockall() 锁定内存，阻止它们的内存换出。


<a id="org7e715a5"></a>

## 内存分配


### 分页

-   Linux内核管理物理内存是通过分页机制实现的，它将整个内存划分成无数个4k（在i386体系结构中）大小的页，从而分配和回收内存的基本单位便是内存页了。


### slab

-   需要，Linux系统采用了一种被称为slab分配器的技术。Slab分配器的实现相当复杂，但原理不难，其核心思想就是“存储池[4]”的运用。内存片段（小块内存）被看作对象，当被使用完后，并不直接释放而是被缓存到“存储池”里，留做下次使用，这无疑避免了频繁创建与销毁对象所带来的额外负载。


### page cache

-   free -m 里面的 cache = page cache
-   Linux中通过page cache机制来加速对磁盘文件的许多访问，当它首次\*\*读取\*\*或\*\*写入\*\*数据介质时，Linux会将数据存储在未使用的内存区中，通过这些区域充当缓存，当发生写操作时，Linux不会立刻执行磁盘写操作，而是把page cache中的页面标记为脏页，定期同步到存储设备。


### buffer

-   是为了提高内存和硬盘（或其他I/0设备）之间的数据交换的速度而设计的。


### 进程与内存

1.  进程对应的内存空间中所包含的5种不同的数据区。

    -   代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。
    -   数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配[1]的变量和全局变量。
    -   BSS段[2]：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。
    -   堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）
    -   栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

2.  进程内存的分配与回收

    -   创建进程fork()、
    -   程序载入execve()
    -   映射文件mmap()
    -   动态内存分配malloc()/brk()等进程


<a id="org28957e8"></a>

## 缓存命中率


### cachestat 提供了整个操作系统缓存的读写命中情况

-   TOTAL ，表示总的 I/O 次数
-   MISSES ，表示缓存未命中的次数
-   HITS ，表示缓存命中的次数
-   DIRTIES， 表示新增到缓存中的脏页数
-   BUFFERS<sub>MB</sub> 表示 Buffers 的大小，以 MB 为单位
-   CACHED<sub>MB</sub> 表示 Cache 的大小，以 MB 为单位。


### cachetop 提供了每个进程的缓存命中情况。


### pcstat 那就是指定文件在内存中的缓存大小


<a id="org1b11567"></a>

## 内存泄露


### 常见原因

-   没正确回收分配后的内存，导致了泄漏。
-   访问的是已分配内存边界外的地址，导致程序异常退出，等等


### memleak 可以跟踪系统或指定进程的内存分配、释放请求，然后定期输出一个未释放内存和相应调用栈的汇总情
