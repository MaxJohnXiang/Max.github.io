---
title: "为什么只看视频/书却学不会东西。"
date: 2019-11-07T13:42:11+08:00
draft: false
sequenceDiagrams: 
  enable: true
  options: "{theme: 'hand'}"

flowchartDiagrams:
  enable: true
  options: "{
              'x': 0,
              'y': 0,
              'line-width': 3,
              'line-length': 50,
              'text-margin': 10,
              'font-size': 14,
              'font-color': 'black',
              'line-color': 'black',
              'element-color': 'black',
              'fill': 'white',
              'yes-text': 'yes',
              'no-text': 'no',
              'arrow-end': 'block',
              'scale': 1,
              'i-am-a-comment-1': 'Do not use //!',
              'i-am-a-comment-2': 'style symbol types',
              'symbols': {
                  'start': {
                    'font-color': 'red',
                    'element-color': 'green',
                    'fill': 'yellow'
                  },
                  'end': {
                      'class': 'end-element'
                  }
              },
              'i-am-a-comment-3': 'even flowstate support ;-)',
              'flowstate': {
                'request': {'fill': 'blue'}
              }
            }"
---
很多人都在反映一个问题，看了很多书，很多视频却没学到多少东西，技术仍然很菜。这是为什么呢。
原因其实很简单，

## 你其实什么都没会， 但是你的大脑欺骗你。

>
这个时候你的大脑只是单纯的输入，在你大脑形成了短期记忆，让你认为你理解了，过一段时间浅层记忆消失，你大概率只记得几个名词， 没有任何实用价值。
举个例子说明，有一天你学习算法，你看了一本书，或者视频， 学习了递归的这个概念。 
-------
> 以下是另一个可能更有利于理解递归过程的解释：
>递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。
> 我们已经完成了吗？如果完成了，返回结果。如果没有这样的终止条件，递归将会永远地继续下去。
> 如果没有，则简化问题，解决较容易的问题，并将结果组装成原始问题的解决办法。然后返回该解决办法。
> 这样就有一种更有趣的描述：“为了理解递归，则必须首先理解递归。”或者更准确地，按照安德鲁·普洛特金的解释：“如果你已经知道了什么是递归，只需记住答案。否则，找一个比你更接近侯世达的人；然后让他／她来告诉你什么是递归。”[1]
> 

>斐波那契数列是典型的递归案例：

```func(n){
if n== 1 {
    return 1
}
return func(n-1) + func(n-2)
}
```

这个时候，你很容易感觉自己已经学会了递归的这个概念， 别人问你递归是什么， 你张嘴回答:
递归就是自己调用自己。
但其实，这个时候， 你只是记忆了文章的一些知识点，或者几句话  当你遇到一个真实的情况， 你就蒙了。例如这个题目

> 第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？

#### 浅层知识的四个层次 
 你会遇到如下几种情况
1. 你想不起来要用递归
2. 我知道用递归但是我学习递归的时候，使用的是斐波那契序列 fn = fn(n-1) + fn(n-2)， 这个感觉和斐波那契差别太大。
3. 你知道要用递归，但是你不知道这个题目要怎么对应递归。
4. 你写了一部分递归，但是代码出现了问题， 跑不出正确的答案。

在做这倒题目的时候， 学过了知道第一直觉是用递归， 第十天，桃子只剩下一个桃子，是明显是递归的终止条件。 (递归一定要有终止条件， 否则是无线递归，直到溢出)

那我就写出来了。 

```go
func stolenPeach(n) {
    if n == 10 {
        return 1
    }
}
```

然后知道递归需要调用自己。则可以这么写


```go
func stolenPeach(n) {
    if n == 10 {
        return 1
    }
    return 调用自己()   此时还不知道。 只是把框架写出来了。 
}
```

这个时候，你如果学过递归， 你应该可以写到这里， 但是这个时候还差多少呢。 
应该还差60%吧，也就是说还差得远。
因为递归最重要的是， 这个时候最重要的是， 猴子偷桃的数量之间有什么关系， 然后把这个关系总结成公式
#第十只猴子来的时候，只有一个桃子 
标记总桃子数量为n 
 那么求第一个猴子，偷的了多少桃子。 
 求总桃子的数量， 那么等于第一个猴子剩下的桃子 n1  * 2 +1
 那么需要求第二个猴子偷的桃子的数量 ，等于第三个猴子偷桃的数量 *2 +1  n3 =n2 *2 +1  就是第二个个猴子的偷的数量

第1只猴子拿了总数的一半加一   n1 = n/2 +1  //剩下n1个桃子
第2只猴子拿了剩下的桃子一半+1 n2 = n1/2 +1   //第二个猴子拿走了n1个桃子了一半+1
第3只猴子拿了剩下的桃子一半+1 n3 = n1/2 +1 
第4只猴子拿了剩下的桃子一半+1 n4 = n1/2 +1 
第5只猴子拿了剩下的桃子一半+1 n5 = n1/2 +1 
第6只猴子拿了剩下的桃子一半+1 n6 = n1/2 +1 
第7只猴子拿了剩下的桃子一半+1 n7 = n1/2 +1 
第8只猴子拿了剩下的桃子一半+1 n8 = n1/2 +1 
第9只猴子拿了剩下的桃子一半+1 n9 = n1/2 +1 
第10只猴子拿了剩下的桃子一半+1 n10 = n1/2 +1 
 n10=1
 
这个时候通过总结归纳， 把猴子偷桃的数量写下来。 开始分析，
得出了这个结论。 n = 2 * (n+1) +1 
这个时候， 我们再完成最终的代码 
```go
func stolenPeach(n) {
    if n == 10 {
        return 1
    }
    return 2 * stolenPeach(n+1) +1    
}
```
一开始的桃子数量为: stolenPeach(1)

这个时候我做出来了这个题目， 我想用这个例子说明什么呢。 你只是单纯的记忆了知识的话， 那这个记忆不属于你。  这个知识并没有经过你的大脑归纳处理和其他的知识产生链接。
**并且在这个过程中， 你的大脑会欺骗你， 自己已经完全掌握了。**
你记得一句话，递归就是自己调用自己。  
这个时候你掌握的知识知识最浅层的知识，基本无法使用。 
举个例子， 你有一个500平的大别墅， 别墅里面有特别多东西，有一天别人告诉你一个东西洗碗机很有用，可以用来洗大量碗。 你听了有道理， 把它放在角落里面， 感到了心满意足。 
1. 突然有一天你有五百个碗要洗， 你甚至不知道你可以用洗碗机解决问题
2. 因为你当时仔细了解了洗碗机的使用范围， 你知道可以用洗碗机，但是你找不到这个机器在哪里， 因为家里机器太多了。 
3. 你找到了洗碗机， 但是你不知道如何使用，
4. 你使用了洗碗机， 因为没有特别深刻了解，点错了按钮，没有放洗碗粉等，碗洗的不干净。


这个例子就是单纯看视频或者阅读学习的过程。从1-4 ，没一层次都是一个理解的层次。
1. 你看了这本书，你不知道这个知识点可以用于干什么。 
2. 你知道知识点可以用来的干什么， 但是你不知道怎么用。 
3. 你会用， 但是因为了解的不清楚，所以用错了。
4. 你非常了解这个知识的使用场景， 并且用于各种场景。

## 如何将浅层理解跃迁到深层理解

任何的知识的掌握一般都是从这几个步骤开始， 从浅层知识逐步到深层知识的理解， 
那么如何从浅层知识慢慢过渡到深度了解呢。 
其实就两点有效输入和有有效输出， 为什么被动的看书学不会， 就是因为这个知识没有经过任何处理。  想象一下， 你写了一个爬虫， 从各大网站抓取了信息， 然后全放在本地文件中了，没有任何分门别类，这些知识是否可以为你所用呢，一共500G  当然不能，当你用的时候， 你只能把硬盘遍历一遍才能找到你需要的数据。 是因为这写数据，没有进行任何处理，所以没有实用价值。 为了让数据能为我们所用，当我们爬取的数据的时候，首先要清洗数据， 将不要的数据， 错误的数据筛出去，然后结构化数据，例如按照来源，网站来源，主题存在mysql数据库不同数据表中，分门别类的存在各个地方，这个时候你用的时候，一个sql语句就能找到你需要的数据。 这个例子想说明， 单纯的读书看视频， 和从网上download一堆数据到你硬盘一样， 没经过清洗，归纳的数据，是没有任何价值的。 
所以当学习一门知识， 最主要的输出建立，输入和输出任务，让这些数据完全成为你知识体系的一部分。
#### 通常有如下几个手段
1. 记录笔记，阅读相关文章，书籍， 思维导图整理，anki，为了防止遗忘反复的输入。
2. 输出最好的则是， 记录博客，写题目， 做项目实战。



## 知识转化流水线
所以一个知识的掌握过程， 应该是一个流水线(pipeline)如下图
以所一个知识的掌握流程,


```
st=>start: Start|past:>http://www.google.com[blank]
e=>end: End:>http://www.google.com
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes
or No?|approved:>http://www.google.com
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

st->op1(right)->cond
cond(yes, right)->c2
cond(no)->sub1(left)->op1
c2(yes)->io->e
c2(no)->op2->e
```



```flowchart
st=>start: 阅读吸收
e=>end: 结束:>http://www.google.com
op1=>operation: 进行主题阅读|past
op2=>operation: 做题自测|current
op3=>operation: 写博客|current
cond2=>condition: Anki复习|current
cond1=>condition: 是否可写出相关题目

st->op1->op2->cond1
cond1(yes)->op3
cond1(no)->op1
op3->cond2
cond2(no)->op2
cond2(yes)->e
```
