+++
title = "Recursion | 递归"
author = ["项云"]
date = 2020-06-11
lastmod = 2020-06-11T18:40:21+08:00
draft = false
+++

## 概念 {#概念}

-   表象上 : function call itself
-   实际上:  Boil down a big problem to smaller ones
-   implementation :
    -   Base case ****smallest problem****
    -   Recursive rule  how to make problem smaller (if we can resolve problem with a samller case )

Call Stack
Global accessible resource
Usage: store the local information for each recursion function


### calculate a ^ b {#calculate-a-b}

> how to calculate a ^ b  (where a is an integer and b is also an integer we do not care about the corner case where a = 0 or b < 0 for now )
> ****Time : O(log(b))
> Space : O(log(b))****


#### 题解 {#题解}

```go
func a_pow_b(a, b int) int {
  // base case
  if b == 0 {
    return 1
  }

  halfResult := a_pow_b(a, b/2)

  if b%2 == 0 {
    return halfResult * halfResult
  } else {
    return halfResult * halfResult * a
  }
}
```


### x 的平方根 {#x-的平方根}

计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。


#### 思路 {#思路}

<!--list-separator-->

-  解法1, 二分查找 timeout 了, 进入了死循环, 因为无法找到完全相等的target

    ```go
      // 9
      // 0 ------4.5
      // 2.25 ---- 4.5
      // 2.25 ---- 3.375
      func mySqrt(x int) int {
      ans := 0
      l := 0
      r := x

      for l <= r {
        mid := l + (r-l)/2
         // 并不是每个数字都有整数的平方根, 只会接近, 不可能完全等于, 所以需要去掉这个条件
        if mid*mid == x {
          return mid
        } else if mid*mid > x {
          // left and  right are both interger , so
          // left = 3 right = 4  mid 3
          // left = 3 right = 4  mid 3
          //会出现这种情况 left always <= right , Infinite loop
          r = mid
        } else {
          l = mid
        }
      }
      return ans
    }
    ```

<!--list-separator-->

-  解法2 牛顿法


### search in a sorted array {#search-in-a-sorted-array}


#### 题目 {#题目}

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
> ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
>
> 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
>
> 你的算法时间复杂度必须是 O(log n) 级别。


#### 思路 {#思路}

-   找到中间点. 通过二分法找到
-   找到中间点之后, 决定二分搜索前半段 还是后半段
-   确定搜索那一段之后,再开始进行二分法搜索
